---
title: "S4 Objects"
author: "David Gerard"
date: "`r Sys.Date()`"
output:  
  html_document:
    toc: true
    toc_depth: 4
    toc_float: false
    highlight: pygments
urlcolor: "blue"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo       = TRUE, 
                      fig.align  = "center",
                      fig.height = 3, fig.width = 4)
ggplot2::theme_set(ggplot2::theme_bw() + ggplot2::theme(strip.background = ggplot2::element_rect(fill = "white")))
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```

# Learning Objectives

- Chapter 15 of [Advanced R](https://adv-r.hadley.nz/)
- [Introduction to Matrix Package](https://cran.r-project.org/web/packages/Matrix/vignettes/Intro2Matrix.pdf)

# Motivation

- Because S3 is really informal, it is also really easy to make dangerous mistakes.

# S4

- All functions for S4 are in the `{methods}` package which comes with R by default.
    - So in a package you either need to import the `{methods}` package, or you need to use `::` to use these functions create S4 objects.
    - Running R in batch mode (e.g. running it on the supercomputer) also does not attach the `{methods}` package, so you need to do `library(methods)` if you intend to use S4 in batch mode.

- In S3, *any* object with a `class` attribute is an S3 object.

- In S4, you need to explicitly run the `methods::setClass()` function to define the class.
    - The `Class` argument is the name of the new class.
    - The `slots` argument contains a *named* character vector with the name of the fields in the class and the type for each field.

    ```{r}
    setClass(
      Class = "Person",
      slots = c(
        name = "character",
         age = "numeric"
      )
    )
    ```

- *Note*: In S4, they call fields **slots** (i.e. data that belongs to the class).

- You then use `methods::new()` to create objects of the given S4 class, specifying the class and filling in the slots.

    ```{r}
    david <- new(Class = "Person", name = "David Gerard", age = 34)
    ```

- `david` is an S4 object
    ```{r}
    sloop::otype(david)
    ```

- You use `methods::is()` to see (via one argument) and test (via two arguments) the S4 class of an object.

    ```{r}
    is(david)
    is(david, "Person")
    ```

- You extract the data from a slot with `methods::slot()`

    ```{r}
    slot(david, "age")
    ```

- Equivalently, you can use `@` notation to extract slots. (You do not use `$` or `[[` notation for S4 objects).

    ```{r}
    david@age
    ```
    
    ```{r, error = TRUE}
    ## will error
    david$age
    ## will error
    david[["age"]]
    ```

- The `@` notation is typically only used internally. If you want folks to access slots, you need to define an **accessor** function. Accessor's are usually methods for S4 generics, so let's go through how to create generics and methods.

- You create generic functions with `setGeneric()`.
    - The `name` is the name of the new generic.
    - The `def` is the function of the generic. Recall that S3 generics are eally simple and just call `UseMethod("generic"). Similarly, S4 generic functions should be really simple and just call `standardGeneric("generic")`.
    
- Below we are defining a generic called `age()` and a generic for `age()<-` which will act as a replacement function.
    ```{r}
    setGeneric(name = "age",
               def = function(x) {
                 standardGeneric("age")
                 }
               )
    setGeneric(name = "age<-", 
               def = function(x, value) {
                 standardGeneric("age<-")
                 }
               )
    ```
    

- You define a method for a given generic with `setMethod()`
    - `f`: The name of the gneric.
    - `Person`: The name of the class(es) to which to apply the method.
    - `definition`: The method function.

    ```{r}
    setMethod(f = "age", 
              signature = "Person", 
              definition = function(x) {
                return(x@age)
              }
             )
    setMethod(f = "age<-",
              signature = "Person",
              definition = function(x, value) {
                x@age <- value
                return(x)
              }
             )
    ```

- Let's look at these

    ```{r}
    age(david)
    ```

- Let's reassign age
    ```{r}
    age(david) <- 21 # ah, young again
    age(david)
    ```

- The `age()` method is called an **accessor** or, more informally, a **getter**.

- The `age()<-` method is called a **replacement function** or, more informally, a **setter**.

- To read the help file of an S4 class, put `class?` before the name of the class. E.g. the following will open up the helpfile of the `GRanges` class from the `{GenomicRanges}` package from Bioconductor.

    ```{r, eval = FALSE}
    library(GenomicRanges)
    class?GRanges
    ```

- To read the help file of method, put a question mark before the call of a generic. E.g., to see the help file for the `coverage()` method of a `GRanges` object, run

    ```{r, eval = FALSE}
    gobj <- GRanges() ## creates empty GRanges object
    ?coverage(gobj) ## opens help file
    ```

- `{sloop}` is useful for seeing 
    1. If an object is an S4 object
        ```{r}
        sloop::otype(david)
        ```
    2. If a function is an S4 generic
        ```{r}
        sloop::ftype(age)
        ```
    3. A list of all methods associated with an S4 class
        ```{r}
        sloop::s4_methods_class("Person")
        ```
    4. A list of all methods associated with an S4 generic
        ```{r, warning = FALSE}
        sloop::s4_methods_generic("age")
        ```
        
- **Exercise**: XYZ

# More on Classes
    

# Some Example Uses of S4 by Others

## `{Matrix}`

- The `{Matrix}` package provides classes for many types of matrices:
    - sparse (mostly zeros)
    - triangular (either the upper or lower triangle elements are all 0).]
    - symmetric (upper and lower triangle elements are equal).
    
    ```{r, message = FALSE}
    library(Matrix)
    ```
    
- Many matrix operations can be more efficiently executed given knowledge of these structures.

- The `USCounties` matrix is a 3111 by 3111 matrix where an element measures a spatial relationship between counties. It is non-zero only if counties are contiguous.

    ```{r}
    data("USCounties", package = "Matrix")
    ```
    
- This is an S4 object of class `dsCMatrix`, used for handling sparse matrices (only 0.0094\% of the values in this matrix are non-zero).

    ```{r}
    sloop::otype(USCounties)
    class(USCounties)
    ```

- Almost every matrix operation you can imagine has been optimized for this sparsity:
    ```{r}
    nrow(sloop::s4_methods_class("dsCMatrix"))
    ```

- This makes things like matrix multiplication much faster:

    ```{r}
    densemat <- as.matrix(USCounties)
    ones <- rep(1, length.out = ncol(densemat))
    microbenchmark::microbenchmark(
      densemat %*% ones,
      USCounties %*% ones
    )
    ```

    - This application doesn't really demonstrate its abilities. It can be even more orders of magnitude faster.

## `{stats4}`

- One application of S4 is in the `{stats4}` package for likelihood inference.

- The **likelihood** is the kind of like the probability of the data that we observed given some parameter values. (not exactly for continuous data)

- E.g., let's say we observed heights (in inches)

    ```{r}
    x <- c(72, 66, 74, 64, 70)
    ```

    and let's assume that these data were generated from a normal distribution.
    
- Then, given any two parameters of the mean (`mu`) and standard deviation (`sigma`), the likelihood of these parameters at each observation would be from `dnorm()`

    ```{r, eval = FALSE}
    dnorm(x = x, mean = mu, sd = sigma)
    ```
    
- If the individuals that these heights are from are **independent** (e.g. they aren't family members), then the likelihood of these parameters given all of the data would be
    ```{r, eval = FALSE}
    prod(dnorm(x = x, mean = mu, sd = sigma))
    ```

- We can calculate this likelihood for a few values of `mu` and `sigma`

    ```{r}
    mu <- 72
    sigma <- 3
    prod(dnorm(x = x, mean = mu, sd = sigma))
    
    mu <- 70
    sigma <- 4
    prod(dnorm(x = x, mean = mu, sd = sigma))
    ```

- Typically, the parameters are not known (`mu` and `sigma` are unknown) and our goal is to estimate them when we only see `x`.

- One way to do this is to find the `mu` and `sigma` that maximize this likelihood. The resulting estimators are called the **maximum likelihood estimators** (MLE's). This is one of the most common methods for estimating parameters from a statistical model.

- Intuition: the MLE's are the parameters that make our observed data as probable to have observed as possible.

- Typically, the likelihood produces very small numbers, so folks maximize the log-likelihood, which results in the same MLE's since $\log()$ is a monotone increasing function.
    ```{r}
    ll <- sum(dnorm(x = x, mean = mu, sd = sigma, log = TRUE)) ## log likelihood
    like <- prod(dnorm(x = x, mean = mu, sd = sigma)) ## likelihood
    
    ## they are the same
    log(like)
    ll
    ```

- The `{stats4}` package provides a bunch of S4 objects and methods for dealing with MLE's.

    ```{r}
    library(stats4)
    ```

- To use the `{stats4}` package, first create a function that takes as input your parameters nothing else. It assumes that all data comes from the parent environment. It should output the *negative* log-likelihood.

    ```{r}
    #' @param mu The mean
    #' @param sigma The standard deviation
    neg_ll <- function(mu, sigma) {
      return(-sum(dnorm(x = x, mean = mu, sd = sigma, log = TRUE)))
    }
    ```

- Then, use the `mle()` function. Include some starting values, and place some limits on constrained parameters.

    ```{r}
    mlout <- stats4::mle(minuslogl = neg_ll, 
                         start = c(mu = 72, sigma = 1), 
                         lower = c(mu = -Inf, sigma = 0),
                         upper = c(mu = Inf, sigma = Inf))
    ```

- This object is S4.
    ```{r}
    sloop::otype(mlout)
    class(mlout)
    ```

- What generics are available for the objects of type `mle`?
    ```{r}
    sloop::s4_methods_class("mle")
    ```

- `coef()` will get you the parameter estimates

    ```{r}
    coef(mlout)
    ```

- `vcov()` will you you the estimated variance/covariance matrix of the MLE's (for their sampling distribution).
    ```{r}
    vcov(mlout)
    ```
    
- So the standard errors are from

    ```{r}
    sqrt(diag(vcov(mlout)))
    ```
    
- `confint()` will get you confidence intervals
    ```{r}
    confint(mlout)
    ```

- In the normal case, these estimates are the same as the sample mean and the sample variance (not adjusting for degrees of freedom).

    ```{r}
    mean(x)
    sqrt(var(x) * (length(x) - 1) / length(x))
    ```

- But the MLE is general to many more complicated applications.

- **Exercise**: The number of heads in $n$ coin flips is binomially distributed with size $n$ and success probability $p$, where $p$ is the probability that a single flip turns up heads. The likelihood, given that `x` heads turned up, is
    ```{r, eval = FALSE}
    dbinom(x = x, size = n, prob = p)
    ```
    
    When $x = 11$ and $n = 31$, calculate the MLE of $p$.

    ```{r, eval = FALSE, echo = FALSE}
    x <- 11
    n <- 31
    neg_ll <- function(pr) {
      -dbinom(x = x, size = n, prob = pr)
    }
    mlout <- mle(minuslogl = neg_ll, 
                 start = c(pr = 0.5), 
                 lower = c(pr = 0), 
                 upper = c(pr = 1))
    coef(mlout)
    ```


# New Functions

- `methods::setClass()`: Define a new S4 class.
- `methods::new()`: Create a new object of a given S4 class.
- `methods::is()`: See the class of an object (if you give it just the object), or test that an object is a certain class (if you give it the object and a class name).
- `methods::slot()`: Extract the data from a slot. Equivalen to `@` notation.
- `methods::setGeneric()`: Create a new generic function
- `methods::setMethod()`: Create a method for a generic.
