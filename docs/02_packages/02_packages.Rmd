---
title: "R Packages"
author: "David Gerard"
date: "`r Sys.Date()`"
output:  
  html_document:
    toc: true
    toc_depth: 4
    toc_float: false
    highlight: pygments
urlcolor: "blue"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo       = TRUE, 
                      fig.align  = "center",
                      fig.height = 3, fig.width = 4)
ggplot2::theme_set(ggplot2::theme_bw() + ggplot2::theme(strip.background = ggplot2::element_rect(fill = "white")))
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```

# Learning Objectives

- Structure of an R package.
- Documenting R packages.
- Workflow for building R packages.
- Required: Chapters 1--10 from [R Packages](https://r-pkgs.org/index.html).
- Resource: [Writing R Extensions](https://cran.r-project.org/doc/manuals/R-exts.html)

# Prereqs

- Make sure you have the following packages installed.
    ```{r, eval = FALSE}
    pkgvec <- c("usethis", "devtools", "roxygen2", "testthat", "knitr")
    for (pkg in pkgvec) {
      if (!requireNamespace(pkg, quietly = TRUE)) 
        install.packages(pkg)  
    }
    ```
    
- The `{usethis}` and `{devtools}` packages automate many of the tedious tasks of package development, allowing you to focus on writing R code. These are the packages we will mostly use.

# Motivation

- Why build an R package?

1. Share your code/methods with others.

2. Re-use functions for yourself.

# Package States

- The same R package is in a different format/state depending at different points of development.

- Source package: A directory of files (R scripts, documentation files, test scripts, etc) with a specific structure. This lecture is about developing source packages.

- Bundled package: A source package that has been compressed into a single file (along with a few other operations). These usually end in ".tar.gz". We use the following to create a bundled package from a source package:
    ```{r, eval = FALSE}
    devtools::build()
    ```
    You typically only do this when you are about to submit to CRAN.

- Binary package: A ready-to-install version for folks who do not have R development tools. You typically don't need to worry about this. If you submit to CRAN, then they will create binaries for you.

- Installed package: Installing a package decompresses/places your package in the library directory. This makes it so that you can use `library()` to load a package.
    - Terminology: A **package** is a collection of functions, along with documentation, in a specific format. A **library** is a directory (folder) on your computer that contains installed packages. 
    - Confusingly, you use the `library()` function to load a package. 
    - You can see your active libraries with
        ```{r}
        .libPaths()
        ```

- Ways to install a package:
    - From CRAN: `install.packages()`.
    - From Bioconductor: `BiocManager::install()`.
    - From source package: `devtools::install()`.
    - From GitHub `devtools::install_github()`.

- In-memory package: makes functions in a package available for use.
    - Use `library()` to place an installed package in memory.
    - Use `devtools::load_all()` to place a source package in memory. You typically do this

# Package Structure

- A typical package will have this directory/file structure
    ```{bash, eval = FALSE}
    .
    ├── DESCRIPTION
    ├── .git
    ├── .gitignore
    ├── LICENSE
    ├── LICENSE.md
    ├── man
    │   ├── f1.Rd
    │   └── f2.Rd
    ├── NAMESPACE
    ├── R
    │   └── rcode.R
    ├── .Rbuildignore
    ├── README.md
    ├── README.Rmd
    ├── src
    │   └── cppcode.cpp
    └── tests
        ├── testthat
        │   └── test-file.R
        └── testthat.R
    ```
    
- Most of these files/folders will be generated by `{devtools}` and `{usethis}`, but you should still know what they are.
    
- `.git` is a hidden directory that git uses to store your version control history. Don't touch this.

- `.gitignore` is a hidden file used to tell git what files/folders to not place under version control.

- `LICENSE` and `LICENSE.md` contain the license that your code is distributed under. Typical open-source licenses are [MIT](https://opensource.org/licenses/MIT) and [GPL-3](https://www.gnu.org/licenses/gpl-3.0).

- The `man` folder contains files that hold your package's documentation. E.g. whenever you use `help()` it uses information from a file in the `man` folder.

- `NAMESPACE` is a file that determines 
    i. What functions you are available to the user of your package (versus what functions are for internal use only), and
    ii. What functions from other packages are you importing.
    
- The `R` folder contains R script files (ending in ".R") that hold all of your R code.

- `.Rbuildignore` is a hidden folder which tells R which files/folders to exclude from the package bundle. You use regular expressions to determine which files to ignore. 
    - E.g. if you have a website in your package folder, then you can exclude it from the bundle by placing that folder's name in `.Rbuildignore`. 
    - You typically just use `usethis::use_build_ignore()` to add files/folders to `.Rbuildignore`.

- `README.md` is the file developers typically first look at, and it is the frontpage of your package's GitHub website. `README.Rmd` is an R markdown file that generates `README.md`.

- `src` is a folder that contains C++ files (ending in ".cpp").

- `tests` is a folder that contains R code for unit-tests, which are automatic checks that you write to determine if your R package works as you intend.

## Create a package skeleton

- You can create a package skeleton with the `usethis::create_package()`.

- Before running this, change your working directory to where you want to create your R package with "Session > Set Working Directory > Choose Directory...".

- This is the "source" state of the package, so you can choose it to be almost anywhere on your computer.

- Choose a location that is not inside an RStudio project, another R package, another git repo, or inside an R library.

- Then just type 
    ```{r, eval = FALSE}
    usethis::create_package(path = ".")
    ```

- I don't like RStudio projects, so I typically run
    ```{r, eval = FALSE}
    usethis::create_package(path = ".", rstudio = FALSE)
    ```
    You can use RStudio Projects if you want. But I won't help with any issues you have with RStudio projects.

# DESCRIPTION file

# The R folder

# Documentation

# Namespace

## Using other packages
- Never use `library()` or `require()` in an R package.

- You call functions from other packages via `package::function()`, where `package` is the name of the package and `function()` is the function name from `package`.

- In order to use any functions from a package, you need to add it to the namespace. Do so once per package with 
    ```{r, eval = FALSE}
    usethis::use_package()
    ```

# Workflow

- Keep working directory at all times at top level of your R package.

- Write all R code in a function.

- Iterate the following until done:
    1. Tweak a function.
    2. Run `devtools::load_all()`
    3. Try out the change by running a small example or some tests.

- `load_all()` is how we can load a source package into memory. This will load all functions (both exported and non-exported).

# Including Datasets

## External data

- External data is available to the user. For example, the `mpg` dataset from the `{ggplot2}` is available to us by running
    ```{r}
    data("mpg", package = "ggplot2")
    str(mpg)
    ```

- To include data in a package, simply add it, in the format of an RData file, in a directory called "data".

- You can use `usethis::use_data()` to save a dataset in the "data" directory. The first argument is the data you want to save.

- You should document your dataset, using roxygen, in a separate R file in the "R" directory. Typically, folks document all of their data in "R/data.R".

- Instead of a function declaration, you just type the name of the dataset. E.g., from my `{updog}` R package I have the following documentation for the `snpdat` tibble.

    ```{r, eval = FALSE}
    #' GBS data from Shirasawa et al (2017)
    #'
    #' Contains counts of reference alleles and total read counts 
    #' from the GBS data of Shirasawa et al (2017) for
    #' the three SNPs used as examples in Gerard et. al. (2018).
    #'
    #' @format A \code{tibble} with 419 rows and 4 columns:
    #' \describe{
    #'     \item{id}{The identification label of the individuals.}
    #'     \item{snp}{The SNP label.}
    #'     \item{counts}{The number of read-counts that support the reference allele.}
    #'     \item{size}{The total number of read-counts at a given SNP.}
    #' }
    #'
    #' @source \doi{10.1038/srep44207}
    #'
    #' @references
    #' \itemize{
    #'   \item{Shirasawa, Kenta, Masaru Tanaka, Yasuhiro Takahata, Daifu Ma, Qinghe Cao, Qingchang Liu, Hong Zhai, Sang-Soo Kwak, Jae Cheol Jeong, Ung-Han Yoon, Hyeong-Un Lee, Hideki Hirakawa, and Sahiko Isobe "A high-density SNP genetic map consisting of a complete set of homologous groups in autohexaploid sweetpotato (Ipomoea batatas)." \emph{Scientific Reports 7} (2017). \doi{10.1038/srep44207}}
    #'   \item{Gerard, D., Ferrão, L. F. V., Garcia, A. A. F., & Stephens, M. (2018). Genotyping Polyploids from Messy Sequencing Data. \emph{Genetics}, 210(3), 789-807. \doi{10.1534/genetics.118.301468}.}
    #' }
    #'
    "snpdat"
    ```

- Never export a dataset (via the `@export` tag).

## Internal Data

- To use pre-computed data, you place all internal data in the "R/sysdata.rda" file.

- `usethis::use_data()` will do this automatically if you use the `internal = TRUE` argument.

- E.g. the following will put `x` and `y` in "R/sysdata.rda"
    ```{r, eval = FALSE}
    x <- c(1, 10, 100)
    y <- data.frame(hello = c("a", "b", "c"), goodbye = 1:3)
    usethis::use_data(x, y, internal = TRUE)
    ```

- You can use internal data in a package as you normally would use an object that is loaded into memory.
