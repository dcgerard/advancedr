---
title: "Vectors"
author: "David Gerard"
date: "`r Sys.Date()`"
output:  
  html_document:
    toc: true
    toc_depth: 4
    toc_float: false
    highlight: pygments
urlcolor: "blue"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo       = TRUE, 
                      fig.align  = "center",
                      fig.height = 3, fig.width = 4)
ggplot2::theme_set(ggplot2::theme_bw() + ggplot2::theme(strip.background = ggplot2::element_rect(fill = "white")))
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```

# Learning Objectives

- Vector Types
- Vector Attributes
- Vectors with attributes: Lists/data frames/matrices/arrays
- Chapter 3 from [Advanced R](https://adv-r.hadley.nz/)
    - These lecture notes are mostly taken straight out of Hadley's book. Many thanks for making my life easier.
    - His images, which I use here, are licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" height="15" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/></a>
- The topic should be mostly review, but we will go a little deeper.

# Vector Types

- Two types of vectors:
    - **Atomic**: All elements of same type.
    - **List** ("generic vectors"): Objects may be of different types.
    - (low-key third type) `NULL`: Absence of a vector.
    
    <img src="./04_figs_vec/summary-tree.png" alt="vector types" width="25%"/>

## Atomic Vectors

- Four basic types:
    - Logical: Either `TRUE` or `FALSE`
    - Integer: 
        - Exactly an integer. Assign them by adding `L` behind it (for "long integer").
        - `-1L`, `0L`, `1L`, `2L`, `3L`, etc...
    - Double: 
        - Decimal numbers.
        - `1`, `1.0`, `1.01`, etc...
        - `Inf`, `-Inf`, and `NaN` are also doubles.
    - Character: 
        - Anything in quotes:
        - `"1"`, `"one"`, `"1 won one"`, etc...

- Integers and doubles are together called "numerics"

    <img src="./04_figs_vec/summary-tree-atomic.png" alt="atomic vector types" width="30%"/>
    
- You can determine the type with `typeof()`.

    ```{r}
    x <- c(TRUE, FALSE)
    typeof(x)
    x <- c(0L, 1L)
    typeof(x)
    x <- c(0, 1)
    typeof(x)
    x <- c("0", "1")
    typeof(x)
    
    typeof(Inf)
    typeof(NaN)
    ```
    
- Determine the length of a vector using `length()`

    ```{r}
    length(x)
    ```

- Missing values are represented by `NA`.

- `NA` is technically is a logical value.

    ```{r}
    typeof(NA)
    ```

    - This rarely matters because logicals get coerced to other types when needed.
    
        ```{r}
        typeof(c(1L, NA))
        typeof(c(1, NA))
        typeof(c("1", NA))
        ```
    
    - But if you need missing values of other types, you can use
    
        ```{r, eval = FALSE}
        NA_integer_ ## integer NA
        NA_real_ ## double NA
        NA_character_ ## character NA
        ```
    
    - Never use `==` when testing for missingness. It will return `NA` since it is always unknown if two unknowns are equal. Use `is.na()`.
    ```{r}
    x <- c(NA, 1)
    x == NA
    is.na(x)
    ```
    
- You can check the type with `is.logical()`, `is.integer()`, `is.double()`, and `is.character()`.

    ```{r}
    is.logical(TRUE)
    is.integer(1L)
    is.double(1)
    is.character("1")
    ```

- Attempting to combine vectors of different types coerces them to one time. The order of preference  is character > integer > double > logical.

    ```{r}
    typeof(c(1L, TRUE))
    typeof(c(1, 1L))
    typeof(c("1", 1))
    ```

- **Exercise** (from Advanced R): Predict the output:
    ```{r, eval = FALSE}
    c(1, FALSE)
    c("a", 1)
    c(TRUE, 1L)
    ```

- **Exercise** (from Advanced R): Explain these results:
    ```{r}
    1 == "1"
    -1 < FALSE
    "one" < 2
    ```

    ```{block, eval = FALSE, echo = FALSE}
    1. `1` is coerced to `"1"`, then tested for equality. So we get `TRUE`.
    
    2. `FALSE` is coerced to 0, so we get `-1 < 0` which is `TRUE`.
    
    3. `2` is coerced to `"2"`, which comes before `"one"` in the [ASCII order](https://en.wikipedia.org/wiki/ASCII#Character_order).
    ```
    
    ```{r, eval = FALSE, echo = FALSE}
    sort(c(letters, LETTERS, 0:9))
    ```

# Attributes

- Attributes are meta information applied to atomic vectors.

- Many common objects (like matrices, arrays, factors, date-times) are just atomic vectors with special attributes.

- You get and set attributes with `attr()`
    ```{r}
    a <- 1:3
    attr(a, "x") <- "abcdef" # sets x attribute of vector a to be "abcdef"
    attr(a, "x") # retrieve the x attribute of vector a
    ```

- You can see all attributes of a vector with `attributes()`.
    ```{r}
    attr(a, "y") <- 4:6
    attributes(a)
    ```

- Attributes are name-value pairs, and all of these attributes are associated with an object:
    
    <img src="./04_figs_vec/attr.png" alt="attributes diagram" width="25%"/>
    
- Most attributes are typically lost by most operations.

    ```{r}
    attributes(a[[1]])
    attributes(sum(a))
    ```

- Two attributes are not log, **names** and **dim**.

## Names

- Names are are a character vector the same length as the atomic vector. Each name corresponds to a single element.

- You could set names using `attr()`, but you should not.

    ```{r}
    x <- 1:3
    attr(x, "names") <- c("a", "b", "c")
    attributes(x)
    ```

- Names are so special, that there are special ways to create them and view them

    ```{r}
    x <- c(a = 1, b = 2, c = 3)
    names(x)
    
    x <- 1:3
    names(x) <- c("a", "b", "c")
    names(x)
    ```

- The proper way to think about names is like this:
    
    <img src="./04_figs_vec/attr-names-1.png" alt="names correct" width="25%"/>
    
    But each name corresponds to a specific element, so Hadley does it like this:
    
    <img src="./04_figs_vec/attr-names-2.png" alt="names intuitive" width="10%"/>  
    
- Names stay with single bracket subsetting (not double bracket subsetting)

    ```{r}
    names(x[1])
    names(x[1:2])
    names(x[[1]])
    ```

- Names can be used for subsetting (more in Chapter 4)
    ```{r}
    x[["a"]]
    ```

## Dimensions

- The dim attribute makes a vector into a **matrix** (a rectangle of numbers) or an **array** (a block of numbers).

- Again, you could use `attr()` to set `dim`, but you should not.
    ```{r}
    x <- 1:6
    attr(x, "dim") <- c(2, 3)
    x
    
    x <- 1:12
    attr(x, "dim") <- c(2, 2, 3)
    x
    ```

- You should either use `matrix()` or `array()` to create these objects, or set the dimension with `dim()`.

    ```{r}
    x <- 1:6
    dim(x) <- c(2, 3)
    dim(x)
    
    x <- matrix(1:6, nrow = 2, ncol = 3)
    dim(x)
    
    x <- 1:12
    dim(x) <- c(2, 2, 3)
    dim(x)
    
    x <- array(1:12, dim = c(2, 2, 3))
    dim(x)
    ```
    
- `length()` still works on 


# New Functions

- `typeof()`
- `attr()`
- `attributes()`
- `structure()`
- `names()`
- `dim()`
